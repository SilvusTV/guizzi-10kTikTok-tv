<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TikTok Follow</title>
  <style>
    :root {
      --bg: #000000;           /* fond noir */
      --fg: #800020;           /* texte par défaut: rouge bordeaux */
      --status-color: #8a8a8a; /* statut sur fond noir */
    }
    /* Thème blanc activé par événement WebSocket */
    .whiteout {
      --bg: #ffffff;
      --fg: #000000;
      --status-color: #000000; /* pas utilisé car on masque le statut */
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
    }
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #value {
      font-size: clamp(3rem, 12vw, 12rem);
      font-weight: 800;
      line-height: 1;
      text-align: center;
      letter-spacing: 0.02em;
    }
    #status {
      position: fixed;
      bottom: 12px;
      left: 12px;
      right: 12px;
      color: var(--status-color);
      font-size: 0.9rem;
      font-weight: 400;
      text-align: center;
      opacity: 0.6;
      user-select: none;
    }
    /* En mode whiteout, cacher le statut pour que la page soit visuellement "entièrement blanche" hormis le texte central */
    body.whiteout #status { display: none; }
  </style>
</head>
<body>
  <div id="value">…</div>
  <div id="status" aria-live="polite"></div>

  <script>
    (() => {
      const qs = new URLSearchParams(location.search);
      // Paramètres: ?base=..., ?username=... (ou ?user=...)
      const base = qs.get('base') || "https://guizzi.server.silvus.me";
      const username = (qs.get('username') || qs.get('user') || 'freekadelle_').trim();

      const elValue = document.getElementById('value');
      const elStatus = document.getElementById('status');

      function show(text) {
        elValue.textContent = text;
      }

      function setStatus(msg) {
        elStatus.textContent = msg || '';
      }

      let lastGood = '';

      // Déclenchement via WebSocket uniquement: aucune requête HTTP n'est faite ici.

      // -------------------- WebSocket: whiteout trigger --------------------
      function toWsUrl(httpBase) {
        try {
          const u = new URL(httpBase);
          u.protocol = (u.protocol === 'https:') ? 'wss:' : 'ws:';
          // Se connecter à la racine du host (ws://host:port)
          u.pathname = '/';
          u.search = '';
          u.hash = '';
          // Retirer trailing slash
          return u.toString().replace(/\/$/, '');
        } catch {
          return (httpBase || '').replace(/^https?:/i, (m) => m.toLowerCase() === 'https:' ? 'wss:' : 'ws:');
        }
      }

      const wsUrl = toWsUrl(base) + '/?id=tv';
      let ws;
      let wsShouldReconnect = true;
      let wsConnecting = false;
      let wsBackoff = 1000; // 1s
      // Timers for keep-alive and periodic scraping
      let keepAliveTimerId = 0;
      let periodicTimerId = 0;
      
      function requestScrape() {
        try {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const msg = { type: 'tiktok:scrape', payload: { username } };
            ws.send(JSON.stringify(msg));
            setStatus(`Commande WS envoyée pour @${username}…`);
            if (!lastGood) show('…');
          }
        } catch {}
      }

      function startWsTimers() {
        // Clear any existing timers first
        stopWsTimers();
        // Keep-alive ping every 30s
        keepAliveTimerId = setInterval(() => {
          try {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'ping', ts: Date.now() }));
            }
          } catch {}
        }, 30000);
        // Periodic scrape every 120s
        periodicTimerId = setInterval(() => {
          requestScrape();
        }, 120000);
      }

      function stopWsTimers() {
        if (keepAliveTimerId) { try { clearInterval(keepAliveTimerId); } catch {} keepAliveTimerId = 0; }
        if (periodicTimerId) { try { clearInterval(periodicTimerId); } catch {} periodicTimerId = 0; }
      }

      function triggerWhiteout() {
        document.body.classList.add('whiteout');
        // Optionnel: forcer la couleur du texte maintenant (variables CSS déjà gèrent)
        setStatus(''); // cacher statut via CSS
      }

      function handleWsMessage(ev) {
        try {
          let rawPayload = ev.data;
          let obj;
          if (typeof rawPayload === 'string') {
            try { obj = JSON.parse(rawPayload); } catch {}
            if (!obj) {
              // Fallback: formats simples, ex: "tiktok:don:2"
              const s = rawPayload.trim();
              const parts = s.split(/[: ,]+/);
              if (parts.length >= 3 && parts[0] === 'tiktok' && parts[1] === 'don') {
                obj = { type: 'tiktok:don', data: Number(parts[2]) };
              }
            }
          } else if (rawPayload instanceof Blob) {
            // Lire Blob comme texte puis reparser
            const reader = new FileReader();
            reader.onload = () => handleWsMessage({ data: String(reader.result || '') });
            reader.readAsText(rawPayload);
            return;
          }

          // Normaliser structure: certains messages ont { from, type, payload, ts }
          const type = obj && (obj.type || (obj.event && obj.event.type));
          const msgPayload = obj && (obj.payload || obj.data || {});

          // 1) Affichage du nombre d'abonnés envoyé par le serveur vers le client TV
          if (type === 'tiktok:followers') {
            const u = (msgPayload && (msgPayload.username || msgPayload.user)) || '';
            const sameUser = !u || u.toLowerCase() === username.toLowerCase();
            if (sameUser) {
              const followers = msgPayload && (msgPayload.followers ?? msgPayload.value ?? msgPayload.count);
              if (followers != null) {
                const text = String(followers);
                show(text);
                lastGood = text;
                const dur = msgPayload && typeof msgPayload.durationMs === 'number' ? ` en ${msgPayload.durationMs} ms` : '';
                setStatus(`Reçu via WS${dur}`);
              }
            }
            return;
          }

          // 2) Erreur de scraping reçue côté TV
          if (type === 'tiktok:followers:error' || type === 'tiktok:scrape:error') {
            const u = (msgPayload && (msgPayload.username || msgPayload.user)) || '';
            const sameUser = !u || u.toLowerCase() === username.toLowerCase();
            if (sameUser) {
              const message = (msgPayload && msgPayload.message) || 'Erreur inconnue';
              if (!lastGood) show('—');
              setStatus(`Erreur scraping: ${message}`);
            }
            return;
          }

          // 3) Accusés de réception/informations (facultatif)
          if (type === 'ack' && msgPayload && msgPayload.cmd === 'tiktok:scrape') {
            const u = (msgPayload && msgPayload.username) || '';
            const sameUser = !u || u.toLowerCase() === username.toLowerCase();
            if (sameUser) setStatus(`Job TikTok lancé pour @${u || username}…`);
            return;
          }
          if (type === 'tiktok:scrape:done') {
            // Certains serveurs notifient aussi le demandeur via WS
            const u = (msgPayload && msgPayload.username) || '';
            const sameUser = !u || u.toLowerCase() === username.toLowerCase();
            if (sameUser && msgPayload && msgPayload.followers != null) {
              const text = String(msgPayload.followers);
              show(text);
              lastGood = text;
              setStatus('Terminé (via WS)');
            }
            return;
          }

          // 4) Ancien trigger "tiktok:don:2" pour whiteout
          if (type === 'tiktok:don') {
            const val = (msgPayload != null ? Number(msgPayload) : Number(obj.data));
            if (!Number.isNaN(val) && val === 2) {
              triggerWhiteout();
            }
            return;
          }
        } catch (e) {
          console.warn('WS message parse error:', e);
        }
      }

      function connectWs() {
        if (wsConnecting || (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING))) return;
        wsConnecting = true;
        try {
          setStatus(`Connexion WS ${wsUrl}…`);
          ws = new WebSocket(wsUrl);
          ws.onopen = () => {
            wsConnecting = false;
            wsBackoff = 1000;
            setStatus('WS connecté — envoi de la commande…');
            startWsTimers();
            requestScrape();
          };
          ws.onmessage = handleWsMessage;
          ws.onerror = () => {
            // Erreur silencieuse; close gérera reconnect
          };
          ws.onclose = () => {
            setStatus('WS déconnecté');
            wsConnecting = false;
            stopWsTimers();
            if (!wsShouldReconnect) return;
            const delay = Math.min(wsBackoff, 10000);
            wsBackoff = Math.min(wsBackoff * 2, 10000);
            setTimeout(connectWs, delay);
          };
        } catch (e) {
          wsConnecting = false;
          setTimeout(connectWs, Math.min(wsBackoff, 10000));
          wsBackoff = Math.min(wsBackoff * 2, 10000);
        }
      }

      connectWs();
      window.addEventListener('beforeunload', () => {
        wsShouldReconnect = false;
        stopWsTimers();
        try { ws && ws.close(); } catch {}
      });
    })();
  </script>
</body>
</html>
