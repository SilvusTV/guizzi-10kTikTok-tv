<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stream</title>
  <style>
    /* Page blanche, rien d'affiché par défaut */
    html, body { height: 100%; margin: 0;}

    /* Lecteur audio YouTube totalement invisible à l'écran (mais présent dans le flux) */
    #bg-audio-player {
      position: fixed;
      width: 1px;
      height: 1px;
      bottom: 0;
      left: 0;
      opacity: 0;
      pointer-events: none;
      z-index: -1;
    }
    #bg-audio-player iframe { width: 1px; height: 1px; border: 0; display: block; }

    /* Copie de l'architecture CSS du reste (tv): .yt-overlay > .yt-frame > iframe */
    .yt-overlay {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 25vw;
      height: 25vh;
      z-index: 10;
    }
    .yt-overlay .yt-frame {
      background: transparent;
      border-radius: 8px;
      overflow: hidden;
      transform: scale(0.50);
      transform-origin: bottom right;
      aspect-ratio: 16/9;
      opacity: 0;
      transition: opacity 200ms ease, transform 200ms ease;
    }
    .yt-overlay.visible .yt-frame {
      opacity: 1;
      transform: scale(1);
    }
    .yt-overlay iframe {
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Lecteur audio YouTube caché -->
  <div id="bg-audio-player" aria-hidden="true"></div>

  <!-- Page blanche: aucun markup initial. Le lecteur est injecté dynamiquement avec
       exactement la même structure que la TV: #yt-overlay.yt-overlay > .yt-frame > iframe -->

  <script>
  (function(){
    // -------- URL params & utils (aucune dépendance externe)
    function qs(name, defVal = ''){
      try { const u = new URL(location.href); return (u.searchParams.get(name) ?? defVal); } catch { return defVal; }
    }
    function toWsUrl(httpBase){
      try {
        const u = new URL(httpBase);
        u.protocol = (u.protocol === 'https:') ? 'wss:' : 'ws:';
        u.pathname = '/';
        u.search = '';
        u.hash = '';
        return u.toString().replace(/\/$/, '');
      } catch {
        return String(httpBase || '')
          .replace(/^https?:/i, m => m.toLowerCase()==='https:' ? 'wss:' : 'ws:')
          .replace(/\/$/, '');
      }
    }
    function getParams(){
      const base = qs('base', 'https://guizzi.server.silvus.me');
      return { base };
    }
    function getWsUrl(base){ return toWsUrl(base) + '/?id=stream'; }

    // -------- WebSocket simple avec reconnexion (API minimale)
    function createWs(url, { onOpen, onMessage, onClose, onError }){
      let ws = null, connecting = false, shouldReconnect = true, backoff = 1000;
      function connect(){
        if (connecting || (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING))) return;
        connecting = true;
        try {
          ws = new WebSocket(url);
          ws.onopen = () => { connecting = false; backoff = 1000; onOpen && onOpen(); };
          ws.onmessage = ev => onMessage && onMessage(ev);
          ws.onerror = ev => onError && onError(ev);
          ws.onclose = () => {
            onClose && onClose();
            connecting = false;
            if (!shouldReconnect) return;
            const delay = Math.min(backoff, 10000);
            backoff = Math.min(backoff * 2, 10000);
            setTimeout(connect, delay);
          };
        } catch(e){
          connecting = false;
          if (!shouldReconnect) return;
          const delay = Math.min(backoff, 10000);
          backoff = Math.min(backoff * 2, 10000);
          setTimeout(connect, delay);
        }
      }
      function close(){ try { shouldReconnect = false; ws && ws.close(); } catch {} }
      return { connect, close };
    }

    // -------- Extraction d'ID YouTube
    function extractYouTubeId(input){
      if (!input || typeof input !== 'string') return '';
      const s = input.trim();
      const patterns = [
        /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([A-Za-z0-9_-]{6,})/i,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?[^\s]*v=([A-Za-z0-9_-]{6,})/i,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([A-Za-z0-9_-]{6,})/i,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([A-Za-z0-9_-]{6,})/i
      ];
      for (const re of patterns){ const m = s.match(re); if (m && m[1]) return m[1]; }
      return '';
    }

    // -------- Lecteur audio YouTube caché (playlist aléatoire quand amount=2)
    const AUDIO_PLAYLIST_ID = 'PLHCb-coSoXZgy8sVsu8HxSykFZEnWFNc5';
    let ytApiReady = false;
    let audioPlayer = null;
    let audioReady = false;
    let pendingPlay = false; // simple drapeau pour rejouer dès que prêt (pas de file)

    // Charger IFrame API YouTube une seule fois
    (function loadYouTubeAPI(){
      if (window.YT && window.YT.Player) { ytApiReady = true; initAudioPlayer(); return; }
      const tag = document.createElement('script');
      tag.src = 'https://www.youtube.com/iframe_api';
      const firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
      window.onYouTubeIframeAPIReady = function(){ ytApiReady = true; initAudioPlayer(); };
    })();

    function initAudioPlayer(){
      try {
        if (!ytApiReady || audioPlayer) return;
        audioPlayer = new YT.Player('bg-audio-player', {
          height: '1', width: '1',
          playerVars: {
            autoplay: 0,
            controls: 0,
            disablekb: 1,
            fs: 0,
            rel: 0,
            modestbranding: 1,
            playsinline: 1
          },
          events: {
            onReady: onAudioReady
          }
        });
      } catch {}
    }

    function onAudioReady(){
      try {
        audioReady = true;
        // Préparer la playlist
        if (audioPlayer && audioPlayer.cuePlaylist) {
          audioPlayer.cuePlaylist({ listType: 'playlist', list: AUDIO_PLAYLIST_ID, index: 0 });
        }
        // Forcer le son à 100%
        if (audioPlayer && audioPlayer.unMute) {
          audioPlayer.unMute();
          audioPlayer.setVolume && audioPlayer.setVolume(100);
        }
        // Si on a demandé une lecture avant que ce soit prêt, lance maintenant
        if (pendingPlay) { pendingPlay = false; playRandomFromPlaylist(); }
      } catch {}
    }

    function playRandomFromPlaylist(retry = 0){
      // Si l'API ou le player ne sont pas prêts, on prépare et on rejouera à onReady
      if (!ytApiReady || !audioPlayer || !audioReady) {
        pendingPlay = true;
        initAudioPlayer();
        return;
      }
      try {
        // Forcer le son à 100%
        audioPlayer.unMute && audioPlayer.unMute();
        audioPlayer.setVolume && audioPlayer.setVolume(100);

        // Récupérer la liste (IDs) déjà hydratée par cuePlaylist()
        const list = audioPlayer.getPlaylist ? audioPlayer.getPlaylist() : null;
        const len = Array.isArray(list) ? list.length : 0;

        if (len > 0) {
          const idx = Math.floor(Math.random() * len);
          const vid = list[idx];
          if (audioPlayer.loadVideoById && vid) {
            // Lire UNE seule vidéo (pas la playlist), pour éviter l'auto-avance
            audioPlayer.loadVideoById(vid);
          } else if (audioPlayer.playVideoAt) {
            // Secours: si loadVideoById indisponible, on lit à l'index
            audioPlayer.playVideoAt(idx);
          } else if (audioPlayer.playVideo) {
            audioPlayer.playVideo();
          }
          return;
        }

        // Si la playlist n'est pas encore prête, on la prépare et on retente rapidement (petit nombre d'essais)
        if (audioPlayer.cuePlaylist) {
          audioPlayer.cuePlaylist({ listType: 'playlist', list: AUDIO_PLAYLIST_ID, index: 0 });
        } else if (audioPlayer.loadPlaylist) {
          audioPlayer.loadPlaylist({ listType: 'playlist', list: AUDIO_PLAYLIST_ID, index: 0 });
        }
        if (retry < 4) {
          setTimeout(() => playRandomFromPlaylist(retry + 1), 400);
        }
      } catch {}
    }

    function stopAudio(){
      try { audioPlayer && audioPlayer.stopVideo && audioPlayer.stopVideo(); } catch {}
    }

    // -------- Affichage YouTube avec EXACTEMENT la même structure que la TV
    let ytTimer = 0;
    function showYouTubePreview(videoId, durationMs = 10000) {
      if (!videoId) return;
      try { if (ytTimer) clearTimeout(ytTimer); } catch {}
      const prev = document.getElementById('yt-overlay');
      if (prev && prev.parentElement) {
        try { prev.parentElement.removeChild(prev); } catch {}
      }
      const overlay = document.createElement('div');
      overlay.id = 'yt-overlay';
      overlay.className = 'yt-overlay visible';
      overlay.setAttribute('aria-hidden', 'true');
      const frame = document.createElement('div');
      frame.className = 'yt-frame';
      const iframe = document.createElement('iframe');
      const params = new URLSearchParams({
        autoplay: '1',
        mute: '0',
        volume: '100',
        controls: '0',
        start: '0',
        end: '10',
        playsinline: '1',
        modestbranding: '1',
        rel: '0'
      });
      iframe.src = `https://www.youtube.com/embed/${encodeURIComponent(videoId)}?${params.toString()}`;
      iframe.allow = 'autoplay; encrypted-media; picture-in-picture';
      iframe.referrerPolicy = 'strict-origin-when-cross-origin';
      frame.appendChild(iframe);
      overlay.appendChild(frame);
      document.body.appendChild(overlay);

      ytTimer = setTimeout(() => {
        try {
          if (overlay && overlay.parentElement) overlay.parentElement.removeChild(overlay);
        } catch {}
        ytTimer = 0;
      }, Math.max(0, Number(durationMs) || 10000));
    }

    // -------- Démarrage: page blanche + WebSocket silencieux
    const { base } = getParams();
    const wsUrl = getWsUrl(base);

    function handleParsedObject(obj){
      const type = obj && (obj.type || (obj.event && obj.event.type));
      const payload = obj && (obj.payload || obj.data || {});
      if (type === 'tiktok:don'){
        if (payload && typeof payload === 'object' && ('amount' in payload)){
          const amount = Number(payload.amount);
          if (!Number.isNaN(amount)){
            if (amount === 2){
              playRandomFromPlaylist();
            } else if (amount === 5){
              const message = (payload && payload.message) ? String(payload.message) : '';
              const vid = extractYouTubeId(message);
              if (vid) showYouTubePreview(vid, 10000);
            }
          }
          return;
        }
        const val = (payload != null ? Number(payload) : Number(obj && obj.data));
        if (!Number.isNaN(val)){
          if (val === 2){ playRandomFromPlaylist(); return; }
          // Ancien format numérique seul: rien à faire sans lien YouTube sinon
          return;
        }
      }
    }

    function processData(str){
      let obj = null;
      if (str) {
        try { obj = JSON.parse(str); } catch {}
        if (!obj) {
          const s = String(str).trim();
          const parts = s.split(/[\s:,]+/);
          if (parts.length >= 3 && parts[0]==='tiktok' && parts[1]==='don') {
            obj = { type: 'tiktok:don', data: Number(parts[2]) };
          }
        }
      }
      if (obj) handleParsedObject(obj);
    }

    const ws = createWs(wsUrl, {
      onOpen(){}, onClose(){}, onError(){},
      onMessage(ev){
        if (typeof ev.data === 'string' || ev.data instanceof String) {
          processData(String(ev.data));
          return;
        }
        if (ev.data instanceof Blob){
          const reader = new FileReader();
          reader.onload = () => processData(String(reader.result || ''));
          reader.readAsText(ev.data);
          return;
        }
      }
    });

    ws.connect();
  })();
  </script>
</body>
</html>
