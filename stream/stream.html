<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stream</title>
  <style>
    /* Page blanche, rien d'affiché par défaut */
    html, body { height: 100%; margin: 0; background: #fff; }

    /* Copie de l'architecture CSS du reste (tv): .yt-overlay > .yt-frame > iframe */
    .yt-overlay {
      position: fixed;
      bottom: 0;
      right: 0;
      width: 50vw;
      height: 50vh;
      z-index: 10;
    }
    .yt-overlay .yt-frame {
      background: transparent;
      border-radius: 8px;
      overflow: hidden;
      transform: scale(0.50);
      transform-origin: bottom right;
      aspect-ratio: 16/9;
      opacity: 0;
      transition: opacity 200ms ease, transform 200ms ease;
    }
    .yt-overlay.visible .yt-frame {
      opacity: 1;
      transform: scale(1);
    }
    .yt-overlay iframe {
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Page blanche: aucun markup initial. Le lecteur est injecté dynamiquement avec
       exactement la même structure que la TV: #yt-overlay.yt-overlay > .yt-frame > iframe -->

  <script>
  (function(){
    // -------- URL params & utils (aucune dépendance externe)
    function qs(name, defVal = ''){
      try { const u = new URL(location.href); return (u.searchParams.get(name) ?? defVal); } catch { return defVal; }
    }
    function toWsUrl(httpBase){
      try {
        const u = new URL(httpBase);
        u.protocol = (u.protocol === 'https:') ? 'wss:' : 'ws:';
        u.pathname = '/';
        u.search = '';
        u.hash = '';
        return u.toString().replace(/\/$/, '');
      } catch {
        return String(httpBase || '')
          .replace(/^https?:/i, m => m.toLowerCase()==='https:' ? 'wss:' : 'ws:')
          .replace(/\/$/, '');
      }
    }
    function getParams(){
      const base = qs('base', 'https://guizzi.server.silvus.me');
      return { base };
    }
    function getWsUrl(base){ return toWsUrl(base) + '/?id=stream'; }

    // -------- WebSocket simple avec reconnexion (API minimale)
    function createWs(url, { onOpen, onMessage, onClose, onError }){
      let ws = null, connecting = false, shouldReconnect = true, backoff = 1000;
      function connect(){
        if (connecting || (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING))) return;
        connecting = true;
        try {
          ws = new WebSocket(url);
          ws.onopen = () => { connecting = false; backoff = 1000; onOpen && onOpen(); };
          ws.onmessage = ev => onMessage && onMessage(ev);
          ws.onerror = ev => onError && onError(ev);
          ws.onclose = () => {
            onClose && onClose();
            connecting = false;
            if (!shouldReconnect) return;
            const delay = Math.min(backoff, 10000);
            backoff = Math.min(backoff * 2, 10000);
            setTimeout(connect, delay);
          };
        } catch(e){
          connecting = false;
          if (!shouldReconnect) return;
          const delay = Math.min(backoff, 10000);
          backoff = Math.min(backoff * 2, 10000);
          setTimeout(connect, delay);
        }
      }
      function close(){ try { shouldReconnect = false; ws && ws.close(); } catch {} }
      return { connect, close };
    }

    // -------- Extraction d'ID YouTube
    function extractYouTubeId(input){
      if (!input || typeof input !== 'string') return '';
      const s = input.trim();
      const patterns = [
        /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([A-Za-z0-9_-]{6,})/i,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?[^\s]*v=([A-Za-z0-9_-]{6,})/i,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([A-Za-z0-9_-]{6,})/i,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([A-Za-z0-9_-]{6,})/i
      ];
      for (const re of patterns){ const m = s.match(re); if (m && m[1]) return m[1]; }
      return '';
    }

    // -------- Affichage YouTube avec EXACTEMENT la même structure que la TV
    let ytTimer = 0;
    function showYouTubePreview(videoId, durationMs = 10000) {
      if (!videoId) return;
      try { if (ytTimer) clearTimeout(ytTimer); } catch {}
      const prev = document.getElementById('yt-overlay');
      if (prev && prev.parentElement) {
        try { prev.parentElement.removeChild(prev); } catch {}
      }
      const overlay = document.createElement('div');
      overlay.id = 'yt-overlay';
      overlay.className = 'yt-overlay visible';
      overlay.setAttribute('aria-hidden', 'true');
      const frame = document.createElement('div');
      frame.className = 'yt-frame';
      const iframe = document.createElement('iframe');
      const params = new URLSearchParams({
        autoplay: '1',
        mute: '1',
        controls: '0',
        start: '0',
        end: '10',
        playsinline: '1',
        modestbranding: '1',
        rel: '0'
      });
      iframe.src = `https://www.youtube.com/embed/${encodeURIComponent(videoId)}?${params.toString()}`;
      iframe.allow = 'autoplay; encrypted-media; picture-in-picture';
      iframe.referrerPolicy = 'strict-origin-when-cross-origin';
      frame.appendChild(iframe);
      overlay.appendChild(frame);
      document.body.appendChild(overlay);

      ytTimer = setTimeout(() => {
        try {
          if (overlay && overlay.parentElement) overlay.parentElement.removeChild(overlay);
        } catch {}
        ytTimer = 0;
      }, Math.max(0, Number(durationMs) || 10000));
    }

    // -------- Démarrage: page blanche + WebSocket silencieux
    const { base } = getParams();
    const wsUrl = getWsUrl(base);

    function handleParsedObject(obj){
      const type = obj && (obj.type || (obj.event && obj.event.type));
      const payload = obj && (obj.payload || obj.data || {});
      if (type === 'tiktok:don'){
        if (payload && typeof payload === 'object' && ('amount' in payload)){
          const amount = Number(payload.amount);
          if (!Number.isNaN(amount) && amount === 5){
            const message = (payload && payload.message) ? String(payload.message) : '';
            const vid = extractYouTubeId(message);
            if (vid) showYouTubePreview(vid, 10000);
          }
          return;
        }
        const val = (payload != null ? Number(payload) : Number(obj && obj.data));
        if (!Number.isNaN(val)){
          // Ancien format numérique seul: rien à faire sans lien YouTube
          return;
        }
      }
    }

    function processData(str){
      let obj = null;
      if (str) {
        try { obj = JSON.parse(str); } catch {}
        if (!obj) {
          const s = String(str).trim();
          const parts = s.split(/[\s:,]+/);
          if (parts.length >= 3 && parts[0]==='tiktok' && parts[1]==='don') {
            obj = { type: 'tiktok:don', data: Number(parts[2]) };
          }
        }
      }
      if (obj) handleParsedObject(obj);
    }

    const ws = createWs(wsUrl, {
      onOpen(){}, onClose(){}, onError(){},
      onMessage(ev){
        if (typeof ev.data === 'string' || ev.data instanceof String) {
          processData(String(ev.data));
          return;
        }
        if (ev.data instanceof Blob){
          const reader = new FileReader();
          reader.onload = () => processData(String(reader.result || ''));
          reader.readAsText(ev.data);
          return;
        }
      }
    });

    ws.connect();
  })();
  </script>
</body>
</html>
